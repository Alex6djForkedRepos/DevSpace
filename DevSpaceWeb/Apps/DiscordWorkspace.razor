@using DevSpaceWeb.Apps.Data
@using DevSpaceWeb.Components.Layout
@using DevSpaceWeb.Data
@using DevSpaceWeb.Data.Permissions
@using DevSpaceWeb.Data.Teams
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using MongoDB.Driver
@using Radzen
@using Radzen.Blazor
@inject IJSRuntime JS
@inject ContextMenuService ContextMenuService
@inject DialogService Dialogs

<div id="WorkspaceLoading" class="dash-box dash-main">
    <h1><span class="iconify" data-icon="mdi:puzzle" style="color: #b55143;"></span> Loading Workspace</h1>
    <p>We are getting your settings and data ready!</p>
</div>
<div id="WorkspaceFailed" class="dash-box dash-main" style="display: none">
    <h1><span class="iconify" data-icon="mdi:puzzle" style="color: #b55143;"></span> Workspace Error</h1>
    <p>Failed to load this workspace :(</p>
</div>
<p style="display: none">@LoadSettings()</p>
@if (Session.UserData != null)
{
    <p id="WorkspaceSetDots" style="display: none">@Settings.GridDotsEnabled</p>
    <p id="WorkspaceSetSnap" style="display: none">@Settings.GridSnapEnabled</p>
    <p id="WorkspaceSetHighlight" style="display: none">@Settings.HighlightEnabled</p>
    <p id="WorkspaceSetMinimap" style="display: none">@Settings.MinimapEnabled</p>
}
else
{
    <p id="WorkspaceSetDots" style="display: none">True</p>
    <p id="WorkspaceSetSnap" style="display: none">True</p>
    <p id="WorkspaceSetHighlight" style="display: none">False</p>
    <p id="WorkspaceSetMinimap" style="display: none">True</p>
}
<div id="WorkspaceDiv">
    <div id="WorkspaceNav">
        <div class="container-fluid">
            <div class="container-start">
                @if (App != null)
                {
                    <Microsoft.AspNetCore.Components.Web.PageTitle>Workspace - @GetName() | @App.Name</Microsoft.AspNetCore.Components.Web.PageTitle>
                    <img src="" onerror="this.onerror=null;this.src='https://cdn.discordapp.com/embed/avatars/0.png';" class="ml-2" style="padding: 4px; margin-top: -8px; padding-bottom: 4px;" />
                    <div class="workspace-name">
                        <h6 class="mt-2 ml-1 top-title">@App.Name - @GetName()</h6>
                    </div>
                }
            </div>
            <div class="container-center">
                @if (App != null)
                {
                    @if (Member.HasAppPermission(Team, App, AppPermission.ManageWorkspaces))
                    {
                        <Radzen.Blazor.RadzenButton Text="Save" ButtonStyle="Radzen.ButtonStyle.Success" Shade="Radzen.Shade.Dark" Click="@SaveWorkspace"></Radzen.Blazor.RadzenButton>
                    }
                    
                    @* <MudButton id="btnSaveWorkspace" Class="ws-button-disabled" Variant="Variant.Filled" Color="Color.Info" @onclick="@(async () => await SaveWorkspace())">Save</MudButton> *@
                    <div id="warningIcon" style="visibility: hidden;"><span class="iconify" data-icon="mdi:warning" style="color: #ff8000;"></span> <p>Invalid Blocks</p></div>
                    <span id="WorkspaceIdValue" style="display: none">@Data.Id.ToString()</span>
                    <span id="workspaceNameValue" style="display: none">@GetName()</span>
                    <span id="workspaceCommandType" style="display: none">@Data.Type.ToString()</span>
                }
            </div>
            <div class="d-flex container-end" style="padding: 4px !important;">
                @if (Data != null && Data.IsPublic)
                {
                    <span id="workspacePublic" class="mr-2">Public Workspace</span>
                }
                else
                {
                    <span id="workspacePublic" class="mr-2">Private Workspace</span>
                }
                <RadzenButton Icon="@(Data.IsPublic ? "public" : "public_off")" Click="@ToggleVisibility" ButtonStyle="ButtonStyle.Base" Variant="Variant.Outlined" Disabled="@(!Member.HasAppPermission(Team, App, DevSpaceWeb.Data.Permissions.AppPermission.ManageWorkspaces))"></RadzenButton>
                <RadzenButton Icon="map" Click="@ToggleMinimap" ButtonStyle="@(Settings.MinimapEnabled? ButtonStyle.Success: ButtonStyle.Danger)" Shade="@(Settings.MinimapEnabled? Shade.Dark: Shade.Darker)" Variant="Variant.Outlined"></RadzenButton>
                <RadzenButton Icon="transition_dissolve" Click="@ToggleDots" ButtonStyle="@(Settings.GridDotsEnabled? ButtonStyle.Success: ButtonStyle.Danger)" Shade="@(Settings.GridDotsEnabled? Shade.Dark: Shade.Darker)" Variant="Variant.Outlined"></RadzenButton>
                <RadzenButton Icon="grid_4x4" Click="@ToggleSnap" ButtonStyle="@(Settings.GridSnapEnabled? ButtonStyle.Success: ButtonStyle.Danger)" Shade="@(Settings.GridSnapEnabled? Shade.Dark: Shade.Darker)" Variant="Variant.Outlined"></RadzenButton>
                <RadzenButton Icon="activity_zone" Click="@ToggleHighlight" ButtonStyle="@(Settings.HighlightEnabled? ButtonStyle.Success: ButtonStyle.Danger)" Shade="@(Settings.HighlightEnabled ? Shade.Dark : Shade.Darker)" Variant="Variant.Outlined"></RadzenButton>
                <RadzenButton Icon="menu" class="ml-2" Click="@(args => ShowContextMenuWithItems(args))" ButtonStyle="ButtonStyle.Light" Variant="Variant.Outlined"></RadzenButton>
                <RadzenButton Style="visibility: hidden;"></RadzenButton>

                @* <MudButton Variant="Variant.Text" OnClick="@(() => SidebarKeyboardOpen = !SidebarKeyboardOpen)"><span class="iconify" data-icon="mdi:keyboard"></span></MudButton>
                <MudMenu AnchorOrigin="Origin.BottomRight">
                    <ActivatorContent>
                        <MudButton Variant="Variant.Text"><span class="iconify" data-icon="mdi:toolbox"></span></MudButton>
                    </ActivatorContent>
                    <ChildContent>
                        <MudMenuItem OnClick="@ToggleMinimap"><span class="iconify" data-icon="mdi:map"></span> @(Settings.MinimapEnabled ? "Disable" : "Enable") Minimap</MudMenuItem>
                        <MudMenuItem OnClick="@ToggleDots"><span class="iconify" data-icon="mdi:dots-grid"></span> @(Settings.GridDotsEnabled ? "Disable" : "Enable") Grid Dots</MudMenuItem>
                        <MudMenuItem OnClick="@ToggleSnap"><span class="iconify" data-icon="mdi:view-grid"></span> @(Settings.GridSnapEnabled ? "Disable" : "Enable") Grid Snap</MudMenuItem>
                        <MudMenuItem OnClick="@ToggleHighlight"><span class="iconify" data-icon="mdi:marker"></span> @(Settings.HighlightEnabled ? "Disable" : "Enable") Highlighter</MudMenuItem>
                    </ChildContent>
                </MudMenu>
                <MudButton Variant="Variant.Text" OnClick="@(() => SidebarSettingsOpen = !SidebarSettingsOpen)"><span class="iconify" data-icon="mdi:cog"></span></MudButton> *@
            </div>
        </div>
    </div>
    <div id="WorkspaceBuilder" style="height: 400px; width: 100%;"></div>
</div>

@if (SidebarKeyboardOpen)
{
@* <MudDrawer Fixed="false" Width="220" Anchor="Anchor.Right" Elevation="1" Variant="@DrawerVariant.Temporary">
    <MudDrawerHeader>
        <MudText Typo="Typo.h6">Keyboard Controls</MudText>
    </MudDrawerHeader>
    <div class="alert alert-secondary" role="alert">
        You can select multiple blocks by holding down <label>ctrl</label>
    </div>
    <h5>Clipboard</h5>
    <p>Copy blocks</p>
    <p><label>Ctrl</label> + <label>C</label></p>
    <p>Paste blocks</p>
    <p><label>Ctrl</label> + <label>V</label></p>
    <br />
    <h5>Workspace</h5>
    <p>Undo previous action</p>
    <p><label>Ctrl</label> + <label>Z</label></p>
    <p>Redo previous action</p>
    <p><label>Ctrl</label> + <label>X</label></p>
    <br />
    <h5>Search</h5>
    <p>Search the toolbox</p>
    <p><label>S</label></p>
    <p>Find blocks in workspace</p>
    <p><label>F</label></p>
    <p>Stop searching</p>
    <p><label>Escape</label></p>
    <br />
    <h5>Basic</h5>
    <p>Select all blocks</p>
    <p><label>Ctrl</label> + <label>A</label></p>
    <p>Delete block(s)</p>
    <p><label>Delete</label></p>
    <p> </p>
    <br />
</MudDrawer> *@
}
@if (SidebarSettingsOpen)
{
    @* <MudDrawer Anchor="Anchor.Right" Fixed="false" Width="260" Elevation="1" Variant="@DrawerVariant.Temporary">
        <MudDrawerHeader>
            <MudText Typo="Typo.h6">Workspace Settings</MudText>
        </MudDrawerHeader>
        <div style="padding-left: 12px; padding-right: 16px;">
        <MudSelect Margin="Margin.Dense" T="string" Value="@("en")" Label="Language" Variant="Variant.Outlined">
            <MudSelectItem Value="@("en")">English</MudSelectItem>
        </MudSelect>
        </div>
        
    </MudDrawer> *@
}
<style>
    .top-row {
        display: none !important;
    }

    .sidebar {
        display: none;
    }

    html, main, .content {
        background-color: #1e1e2d !important;
    }

    .content {
        padding-top: 0px;
    }

    .top-row, article {
        padding-left: 30px !important;
        padding-right: 30px !important;
    }

    .blocklyZoom > image, .blocklyTrash {
        opacity: 0.8 !important;
    }

    .mud-drawer {
        background-color: #1f2129 !important;
    }

        .mud-drawer .alert {
            border-color: #18191c !important;
            color: #d9d9d9 !important;
            background-color: #181818 !important;
            margin-left: 6px;
            margin-right: 8px;
        }

        .mud-drawer .mud-typography-h6 {
            color: rgb(147, 122, 222);
        }

        .mud-drawer h5 {
            margin-left: 10px;
            margin-top: 6px;
            margin-bottom: 16px !important;
            color: white;
        }

        .mud-drawer p {
            margin-left: 20px;
            line-height: 0.8;
            color: #bbbbbf;
        }

        .mud-drawer label {
            background-color: #333333;
            padding: 4px;
            padding-left: 10px;
            padding-right: 10px;
            border-radius: 6px;
            color: #d9d9d9 !important;
        }
        .content, html, main, .container-fluid {
    background-color: rgba(24,25,28,1) !important;
}
.blocklyToolboxDiv {
    background-color: #2b2d31 !important;
}
.ws-button-disabled {
  box-shadow: none;
  background-color: var(--mud-palette-action-disabled-background) !important;
  color: var(--mud-palette-action-disabled) !important;
  cursor: default;
  pointer-events: none;
}
#warningIcon {
    display: inline-block;
    margin-left: 10px;
    cursor: pointer;
}
#warningIcon .iconify {
    margin-bottom: -8px;
    width: 26px;
    height: 26px;
}
#warningIcon p {
    display: inline-block;
    font-weight: 600;
    margin-left: 6px;
}

    .blocklyToolboxCategory .iconify {
        display: inline-block;
        margin-top: -8px !important;
        padding: 2px;
    }

    .blocklyToolboxCategoryLabel {
        display: inline-block;
        margin-top: -8px !important;
    }

    .blocklyToolboxCategory {
        padding-top: 3px;
        padding-bottom: 3px;
    }

        .blocklyWidgetDiv .blocklyHtmlInput, .blocklyToolboxCategory input, .blockly-ws-search-input input {
        color: #000 !important;
    }

    #blockly-0 {
        height: 32px !important;
    }

    .rz-p-1 {
        padding: 0 !important;
    }
</style>

<script type="module">
    import './js/blocky/main/main_blocks.js?v=4';
    import './js/blocky/main/api_blocks.js?v=2';
    import './js/blocky/main/logic_blocks.js?v=2';
    import './js/blocky/main/file_blocks.js?v=2';
    import './js/blocky/main/json_blocks.js?v=2';

    import './js/blocky/plugins/toolbox_search.js?v=2';

    /* Action scripts */
    import './js/blocky/discord/actions/discord_actions_channels.js?v=1';
    import './js/blocky/discord/actions/discord_actions_webhooks.js?v=1';
    import './js/blocky/discord/actions/discord_actions_members.js?v=1';
    import './js/blocky/discord/actions/discord_actions_messages.js?v=3';
    import './js/blocky/discord/actions/discord_actions_components.js?v=1';
    import './js/blocky/discord/actions/discord_actions_servers.js?v=1';
    import './js/blocky/discord/actions/discord_actions_roles.js?v=1';
    import './js/blocky/discord/actions/discord_actions_users.js?v=1';

    import './js/blocky/discord/discord_options.js?v=1';
    import './js/blocky/discord/discord_main.js?v=1';
    import './js/blocky/discord/discord_inputs.js?v=1';

    /* Data scrips */
    import './js/blocky/discord/data/discord_data_channels.js?v=2';
    import './js/blocky/discord/data/discord_data_webhooks.js?v=2';
    import './js/blocky/discord/data/discord_data_members.js?v=2';
    import './js/blocky/discord/data/discord_data_messages.js?v=2';
    import './js/blocky/discord/data/discord_data_servers.js?v=2';
    import './js/blocky/discord/data/discord_data_emojis.js?v=2';
    import './js/blocky/discord/data/discord_data_roles.js?v=2';
    import './js/blocky/discord/data/discord_data_users.js?v=2';

    import './js/blocky/discord/discord_logic.js?v=2';

        import {
      ScrollOptions
    } from './js/blocky/plugins/scroll/drag_scroll.js';

    import {ScrollMetricsManager,
    } from './js/blocky/plugins/scroll/metrics.js';

    import {
      ScrollBlockDragger,
    } from './js/blocky/plugins/scroll/dragger.js';

    try {

        const DarkTheme = Blockly.Theme.defineTheme('themeName', {
            'base': Blockly.Themes.Classic,
            'componentStyles': {
                'workspaceBackgroundColour': "#1e1e1e",
                'toolboxBackgroundColour': "blackBackground",
                'toolboxForegroundColour': "#fff",
                'flyoutBackgroundColour': "#252526",
                'flyoutForegroundColour': "#ccc",
                'flyoutOpacity': 1,
                'scrollbarColour': "#797979",
                'insertionMarkerColour': "#fff", 'insertionMarkerOpacity': .3, 'scrollbarOpacity': .4,
                'cursorColour': "#d0d0d0", 'blackBackground': "#333"
            },
            'blockStyles': {
                'math_blocks': {
                    'colourPrimary': 120
                },
                "text_blocks": {
                    'colourPrimary': 120
                },
                "colour_blocks": {
                    'colourPrimary': 120
                },
                "logic_blocks": {
                    'colourPrimary': 230
                }
            }
        });

        

        window.blazorExtensions = {
            WarningsEnabled: false,
            WarningList: new Map(),
            CheckWarning: function() {
                var elm = document.getElementById('btnSaveWorkspace');
                if (elm) {
                    if (window.blazorExtensions.WarningList.size == 0) {
                        document.getElementById('warningIcon').style.visibility = "hidden";
                        elm.classList.remove('ws-button-disabled');
                    }
                    else {
                        document.getElementById('warningIcon').style.visibility = "";
                        elm.classList.add('ws-button-disabled');
                    }
                }
            },
            ExportData: function () {
                var json = JSON.stringify(Blockly.serialization.workspaces.save(workspace));

                var a = document.createElement("a");
                var file = new Blob([json], { type: "text/plain" });
                a.href = URL.createObjectURL(file);
                a.download = document.getElementById('workspaceNameValue').textContent + ".json";
                a.click();
            },
            ImportData: function () {
                var jsonString = prompt("Import command json data");
                var commandType = document.getElementById('workspaceCommandType').textContent;
                var json;
                var typeAllowed = false;
                try
                {
                    json = JSON.parse(jsonString);
                    var blockType = json.blocks.blocks[0].type;
                    switch (commandType) {
                        case "DiscordSlashCommand":
                        if (blockType == "block_command") {
                            typeAllowed = true;
                        }
                        break;
                        case "DiscordUserCommand":
                        if (blockType == "block_user_command") {
                            typeAllowed = true;
                        }
                        break;
                        case "DiscordMessageCommand":
                        if (blockType == "block_message_command") {
                            typeAllowed = true;
                        }
                        break;
                        case "DiscordInteractionButton":
                        if (blockType == "block_interaction_button") {
                            typeAllowed = true;
                        }
                        break;
                        case "DiscordInteractionModal":
                        if (blockType == "block_interaction_modal") {
                            typeAllowed = true;
                        }
                        break;
                    }
                }
                catch
                {
                    alert('Failed to parse json data.');
                }

                if (typeAllowed) {
                    try {
                        json.blocks.blocks[0].fields["name"] = document.getElementById('workspaceNameValue').textContent;
                        window.testData = json;
                        Blockly.serialization.workspaces.load(json, workspace);
                    }
                    catch {
                        alert('Failed to import workspace data.');
                    }
                    
                }
            },
            CheckInputsEmpty(block, inputs) {
                if (block.workspace.id !== Blockly.getMainWorkspace().id)
                    return;
                if (block.isInFlyout || block.isInsertionMarker_)
                    return;

                var isInputEmpty = false;
                inputs.forEach(x => {
                    if (!isInputEmpty && x.connection) {
                        if (!x.connection.isConnected()) {
                            if (x.name)
                                block.setWarningText(x.name + ' input is missing.');
                            else
                                block.setWarningText('Input is missing.');
                            isInputEmpty = true;
                        }
                        // else {
                        //     console.log(x);
                        //     if ((x.connection.targetBlock().type === "text" || x.connection.targetBlock().type === "text_multiline") && x.connection.targetBlock().inputList[0].fieldRow[1].value_ === "") {
                        //         if (x.name)
                        //             block.setWarningText(x.name + ' input requires text.');
                        //         else
                        //             block.setWarningText('Input requires text.');
                        //         isInputEmpty = true;
                        //     }
                        // }
                        
                    }
                });

                if (isInputEmpty) {
                    window.blazorExtensions.WarningList.set(block.id + '-input', block.id);
                }
                else {
                    window.blazorExtensions.WarningList.delete(block.id + '-input');
                    if (!window.blazorExtensions.WarningList.has(block.id + '-field'))
                        block.setWarningText(null);
                }

                window.blazorExtensions.CheckWarning();
            },
            CheckFieldsEmpty(block, fields) {
                if (block.workspace.id !== Blockly.getMainWorkspace().id)
                    return;

                var isInputEmpty = false;

                fields.forEach(x => {
                    if (!x.value_ === "") {
                        if (x.name)
                            block.setWarningText(x.name + ' field requires text.');
                        else
                            block.setWarningText('Field requires text.');
                        isInputEmpty = true;
                    }
                });

                if (isInputEmpty) {
                    window.blazorExtensions.WarningList.set(block.id + '-field', block.id);
                }
                else {
                    window.blazorExtensions.WarningList.delete(block.id + '-field');
                    if (!window.blazorExtensions.WarningList.has(block.id + '-input'))
                        block.setWarningText(null);
                }

                window.blazorExtensions.CheckWarning();
            },
            GetWorkspaceJson: function () {
                let Json = JSON.stringify(Blockly.serialization.workspaces.save(Blockly.getMainWorkspace()));
                return Json;
            },
            GetToolboxJson: async function () {
                console.log('load Toolbox');
                try {
                    var response = null;
                    if (document.getElementById('WorkspaceIdValue') !== null) {
                        response = await fetch('./dev/workspace/toolbox?id=' + document.getElementById('WorkspaceIdValue').innerText);
                    }
            
            if (!response || !response.ok) {
                document.getElementById('WorkspaceLoading').style.display = "none";
                document.getElementById('WorkspaceDiv').style.display = "none";
                document.getElementById('WorkspaceFailed').style.display = "block";
                throw Error("Error response");
            }

            var json = await response.json();

            return new Promise((resolve) => {
                resolve(json);
            });
        } catch (error) {
            document.getElementById('WorkspaceLoading').style.display = "none";
           document.getElementById('WorkspaceDiv').style.display = "none";
           document.getElementById('WorkspaceFailed').style.display = "block";
           throw Error("Failed to send request: " + error);
        }

            },
            SendSaveRequest: function (workspaceid, name) {
                    try
                    {
                    document.getElementById('btnSaveWorkspace').classList.add('ws-button-disabled');
                    }
                    catch { }
                    //Update to this
                    fetch('./dev/workspace/update?id=' + workspaceid + "&name=" + name, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        body: window.blazorExtensions.GetWorkspaceJson()
                    });
                
            },
            LoadWorkspaceJson: function (workspace) {
                console.log('load Workspace');
                fetch('./dev/workspace/fetch?id=' + document.getElementById('WorkspaceIdValue').innerText, {
                method: 'GET'
                })
                .then((response) => { if (response.ok) { return response.json() } else { document.getElementById('WorkspaceFailed').style.display = ""; document.getElementById('WorkspaceDiv').style.display = "none"; } })
                .then((data) => {
                    try {
                        Blockly.serialization.workspaces.load(data, workspace);
                        window.blazorExtensions.WarningsEnabled = true;
                        if (document.getElementById('WorkspaceSetDots').innerText === "False") {
                            workspace.options.gridPattern.style.display = "none";
                }
                if (document.getElementById('WorkspaceSetSnap').innerText === "False") {
                    window.WorkspaceUtils.ToggleSnap();
                }
                if (document.getElementById('WorkspaceSetHighlight').innerText === "True") {
                    window.WorkspaceUtils.ToggleHighlight();
                }
                if (document.getElementById('WorkspaceSetMinimap').innerText === "False") {
                    window.WorkspaceUtils.ToggleMinimap();
                }
                    }
                    catch (exe) {
                        console.log(exe);

        document.getElementById('WorkspaceLoading').style.display = "none";
        document.getElementById('WorkspaceDiv').style.display = "none";
        document.getElementById('WorkspaceFailed').style.display = "block";
                    }
                });
            }
        }


        let getToolbox = await window.blazorExtensions.GetToolboxJson();

        const options = {
            maxBlocks: 1000,
            toolbox: getToolbox.toolbox,
            theme: DarkTheme,
            "collapse": false,
            "sounds": false,
            "grid": {
                "spacing": 20,
                "length": 3,
                "colour": '#ccc',
                "snap": true
            },
            "zoom": {
                "controls": true,
                "wheel": true,
                "startScale": 1.0,
                "maxScale": 2.0,
                "minScale": 0.5,
                "scaleSpeed": 1.1,
            },
            "oneBasedIndex": false,
            "maxTrashcanContents": 5,
            "plugins": {
                "connectionChecker": CustomConnectionManager,
                "blockDragger": ScrollBlockDragger,
                "metricsManager": ScrollMetricsManager,
            },
            //"media": "https://novanode.dev/img/",
            "bumpNeighbours": true,
            "multiselectIcon": {
                "hideIcon": true,
                "weight": 3,
                "enabledIcon": 'https://github.com/mit-cml/workspace-multiselect/raw/main/test/media/select.svg',
                "disabledIcon": 'https://github.com/mit-cml/workspace-multiselect/raw/main/test/media/unselect.svg',
            },
            "maxBlocks": 1000,
            "maxInstances": {
                "option_require_app_premium": 1,
                "option_ephemeral": 1,
                "option_nsfw_only": 1,
                "option_app_owner_only": 1,
                "option_app_developer_only": 1,
                "option_server_owner_only": 1,
                "option_require_server": 1,
                "option_require_private_channel": 1,
                "option_require_group_channel": 1,
                "option_allow_user_apps": 1,
                "option_open_modal": 1
            },
            "multiselectCopyPaste": {
                // Enable the copy/paste accross tabs feature (true by default).
                "crossTab": false,
                // Show the copy/paste menu entries (true by default).
                "menu": true,
            }
        };

        

        const workspace = Blockly.inject('WorkspaceBuilder', options);

        try
        {
        document.getElementById('warningIcon').addEventListener('click', function () {
            window.blazorExtensions.WarningList.forEach(x => { workspace.blockDB.get(x)?.warning.setBubbleVisible(true) }); 
        });
        }
        catch { }

        if (getToolbox.type !== 0) {
            workspace.toolbox.getToolboxItems().find(x => x.name_ == "Inputs").hide();
        }
        if (getToolbox.type !== 4) {
            workspace.toolbox.getToolboxItems().find(x => x.name_ == "Fields").hide();
        }

        let keepToolboxOpen = false;

        workspace.addChangeListener(function (event) {
            
            if (event.type === "delete") {
                window.blazorExtensions.WarningList.delete(event.blockId + '-input');
                window.blazorExtensions.WarningList.delete(event.blockId + '-field');
            }
            if ((event.recordUndo != null && event.recordUndo && window.blazorExtensions.WarningList.size == 0)) {
                var elm = document.getElementById('btnSaveWorkspace');

                if (elm) {
                    elm.classList.remove('ws-button-disabled') 
                }
                    
            }

            if (event.reason && (event.reason[0] === "drag" || event.reason[0] === "connect")) {
                if (keepToolboxOpen) {
                    workspace.toolbox.setSelectedItem(workspace.toolbox.getPreviouslySelectedItem())
                    keepToolboxOpen = false;
                }
                
            }
            else if (event.type === "create" && event.json) {
                keepToolboxOpen = true;
            }
        });

        // workspace.getFlyout().getWorkspace().addChangeListener(function (event) {
        //     if (event.type === "create" && event.json.type === "math_change") {
        //         workspace.getFlyout().getWorkspace().blockDB.forEach(x => { if (x.type === "math_change") { console.log(x); window.test = x; } })
        //     }
        // });

        const workspaceSearch = new WorkspaceSearch(workspace);
        workspaceSearch.init();

        const minimap = new PositionedMinimap(workspace);
        minimap.init();
        minimap.enableFocusRegion();
        workspace.markFocused()

        const contentHighlight = new ContentHighlight(workspace);
        window.WorkspaceUtils.Plugins.Highlighter = contentHighlight;

        const scrollPlugin = new ScrollOptions(workspace);
        scrollPlugin.init({ enableWheelScroll: false, enableEdgeScroll: true });

        if (document.getElementById('WorkspaceIdValue') !== null) {
            window.blazorExtensions.LoadWorkspaceJson(workspace);
            document.getElementById('WorkspaceLoading').style.display = "none";
        }

        
    }
    catch (exe) {
        console.log(exe);

        document.getElementById('WorkspaceLoading').style.display = "none";
        document.getElementById('WorkspaceDiv').style.display = "none";
        document.getElementById('WorkspaceFailed').style.display = "block";
    }
</script>

@code {
    [CascadingParameter]
    public SessionProvider Session { get; set; }

    public bool SidebarKeyboardOpen { get; set; }
    public bool SidebarSettingsOpen { get; set; }

    [Parameter]
    public bool DebugMode { get; set; }

    [Parameter]
    public int MaxBlocks { get; set; } = 1000;

    [Parameter]
    public AppData? App { get; set; }

    [Parameter]
    public TeamData? Team { get; set; }

    [Parameter]
    public TeamMemberData? Member { get; set; }

    [Parameter]
    public WorkspaceData? Data { get; set; }

    public string LoadSettings()
    {
        if (Settings == null)
        {
            if (Session.UserData != null)
                Settings = Session.UserData.WorkspaceSettings;
            else
                Settings = new UserWorkspaceSettings();
        }

        return string.Empty;
    }

    public string GetName()
    {
        switch (Data.Type)
        {
            case WorkspaceType.DiscordSlashCommand:
                {
                    DiscordAppSlashCommand? cmd = null;
                    if (string.IsNullOrEmpty(Data.ServerId))
                        App.SlashCommands.TryGetValue(Data.CommandFormat, out cmd);
                    else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                        sc.SlashCommands.TryGetValue(Data.CommandFormat, out cmd);

                    if (cmd == null && Data.CommandFormat.Contains(" "))
                    {
                        if (string.IsNullOrEmpty(Data.ServerId))
                            App.SlashCommands.TryGetValue(Data.CommandFormat.Split(' ').First(), out cmd);
                        else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                            sc.SlashCommands.TryGetValue(Data.CommandFormat.Split(' ').First(), out cmd);
                    }

                    if (cmd != null)
                    {
                        if (cmd.WorkspaceId == Data.Id)
                            return cmd.Name;
                        else
                        {
                            string CommandName = cmd.Name;
                            var Find = cmd.Commands.Values.FirstOrDefault(x => x.WorkspaceId == Data.Id);
                            if (Find == null)
                            {
                                string SubName = "";
                                foreach (var sub in cmd.SubGroups.Values)
                                {
                                    SubName = sub.Name;
                                    Find = sub.Commands.Values.FirstOrDefault(x => x.WorkspaceId == Data.Id);
                                    if (Find != null)
                                        break;
                                }

                                if (Find != null)
                                    CommandName = $"{CommandName} {SubName} {Find.Name}";
                            }
                            else
                                CommandName = $"{CommandName} {Find.Name}";

                            return CommandName;
                        }

                    }
                }
                break;
            case WorkspaceType.DiscordUserCommand:
                {
                    IDiscordAppCommand? cmd = null;
                    if (string.IsNullOrEmpty(Data.ServerId))
                        App.UserCommands.TryGetValue(Data.CommandFormat, out cmd);
                    else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                        sc.UserCommands.TryGetValue(Data.CommandFormat, out cmd);

                    if (cmd != null)
                        return cmd.Name;
                }
                break;
            case WorkspaceType.DiscordMessageCommand:
                {
                    IDiscordAppCommand? cmd = null;
                    if (string.IsNullOrEmpty(Data.ServerId))
                        App.MessageCommands.TryGetValue(Data.CommandFormat, out cmd);
                    else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                        sc.MessageCommands.TryGetValue(Data.CommandFormat, out cmd);

                    if (cmd != null)
                        return cmd.Name;
                }
                break;
            case WorkspaceType.DiscordInteractionButton:
                {
                    App.ButtonInteractions.TryGetValue(Data.CommandFormat, out var cmd);
                    if (cmd != null)
                        return cmd.Name;
                }
                break;
            case WorkspaceType.DiscordInteractionModal:
                {
                    App.ModalInteractions.TryGetValue(Data.CommandFormat, out var cmd);
                    if (cmd != null)
                        return cmd.Name;
                }
                break;
        }


        return string.Empty;
    }

    public UserWorkspaceSettings Settings;

    public void ToggleMinimap()
    {
        Settings.MinimapEnabled = !Settings.MinimapEnabled;
        if (Session.UserData != null)
        {
            Session.UserData.WorkspaceSettings.MinimapEnabled = Settings.MinimapEnabled;
        }

        JS.InvokeVoidAsync("window.WorkspaceUtils.ToggleMinimap");
    }
    public void ToggleDots()
    {
        Settings.GridDotsEnabled = !Settings.GridDotsEnabled;
        if (Session.UserData != null)
        {
            Session.UserData.WorkspaceSettings.GridDotsEnabled = Settings.GridDotsEnabled;        
        }


        JS.InvokeVoidAsync("window.WorkspaceUtils.ToggleGrid");
    }
    public void ToggleSnap()
    {
        Settings.GridSnapEnabled = !Settings.GridSnapEnabled;
        if (Session.UserData != null)
        {
            Session.UserData.WorkspaceSettings.GridSnapEnabled = Settings.GridSnapEnabled;
        }

        JS.InvokeVoidAsync("window.WorkspaceUtils.ToggleSnap");
    }
    public void ToggleHighlight()
    {
        Settings.HighlightEnabled = !Settings.HighlightEnabled;
        if (Session.UserData != null)
        {
            Session.UserData.WorkspaceSettings.HighlightEnabled = Settings.HighlightEnabled;
        }

        JS.InvokeVoidAsync("window.WorkspaceUtils.ToggleHighlight");
    }

    // [JSInvokable]
    // public static async Task LoadJsonAsync(IJSObjectReference objRef)
    // {
    //     Console.WriteLine("Invoke load");
    //     await objRef.InvokeVoidAsync("window.blazorExtensions.LoadWorkspaceJson", Newtonsoft.Json.JsonConvert.SerializeObject(_Data.Global.DevEnvironment.Discord.ToolboxWorkspace));

    // }

    // [JSInvokable]
    // public static async Task<string> GetJsonAsync()
    // {
    //     return Newtonsoft.Json.JsonConvert.SerializeObject(_Data.Global.DevEnvironment.Discord.ToolboxItem);
    // }

    public async Task SaveWorkspace()
    {
        if (Data != null)
            await JS.InvokeAsync<string>("window.blazorExtensions.SendSaveRequest", Data.Id.ToString(), GetName());
        else
            await JS.InvokeAsync<string>("window.blazorExtensions.SendSaveRequest", "test", "test");
    }

    public bool JsonLoaded = false;

    //protected override async Task OnAfterRenderAsync(bool firstRender)
    //{

    //}

    //protected override async Task OnParametersSetAsync()
    //{
    //JS.InvokeVoidAsync("window.WorkspaceUtils.SetMaxBlocks", MaxBlocks);
    //}

    public async Task ToggleVisibility()
    {
        TeamData? team = App.Team;
        if (team == null)
            return;

        TeamMemberData? member = team.GetMember(Session.CurrentUser);
        if (member == null)
            return;

        if (!member.HasAppPermission(team, App, DevSpaceWeb.Data.Permissions.AppPermission.ManageWorkspaces))
            return;

        if (Data.IsPublic)
        {
            bool Confirm = await Dialogs.ShowConfirmAsync("Set Private Workspace", "This will hide the workspace publicly and only members in your team can access this workspace.", "Confirm", ButtonStyle.Success);
            if (!Confirm)
                return;

            await Data.UpdateAsync(new UpdateDefinitionBuilder<WorkspaceData>().Set(x => x.IsPublic, false), () =>
            {
                Data.IsPublic = false;
            });
        }
        else
        {
            bool Confirm = await Dialogs.ShowConfirmAsync("Set Public Workspace", "This will make the workspace public, anyone can view your block data, fields, comments and inputs.", "Confirm", ButtonStyle.Success);
            if (!Confirm)
                return;

            await Data.UpdateAsync(new UpdateDefinitionBuilder<WorkspaceData>().Set(x => x.IsPublic, true), () =>
            {
                Data.IsPublic = true;
            });

            await Dialogs.ShowInfoAsync("Public Workspace", $"Anyone can view your workspace at {_Data.Config.Instance.GetPublicUrl()}/workspaces/{App.Id.ToString()}/{Data.Id.ToString()}/share");
        }
    }

    void ShowContextMenuWithItems(MouseEventArgs args)
    {
        ContextMenuService.Open(args,
            new List<ContextMenuItem> {
                new ContextMenuItem(){ Text = "Export", Value = "export", Icon = "download" },
                new ContextMenuItem(){ Text = "Import", Value = "import", Icon = "tab_move" },
                new ContextMenuItem(){ Text = "Copy Name", Value = "copy_name", Icon = Data.Type == WorkspaceType.DiscordSlashCommand ? "pen_size_3" : "content_copy" },
                new ContextMenuItem() { Text = "Copy Command Format", Value = "copy_format", Icon = "text_ad", Disabled = Data.Type != WorkspaceType.DiscordSlashCommand },
                new ContextMenuItem(){ Text = "Copy ID", Value = "copy_id", Icon = "content_copy", Disabled = Data.Type != WorkspaceType.DiscordSlashCommand },
         }, OnMenuItemClick);
    }

    void OnMenuItemClick(MenuItemEventArgs args)
    {
        ContextMenuService.Close();
        switch ((string)args.Value)
        {
            case "export":
                JS.InvokeAsync<dynamic>("window.blazorExtensions.ExportData");
                break;
            case "import":
                JS.InvokeAsync<dynamic>("window.blazorExtensions.ImportData");
                break;
            case "copy_name":
                if (Data.Type == WorkspaceType.DiscordSlashCommand)
                    _ = JS.CopyTextAsync("/" + GetName());
                else
                    _ = JS.CopyTextAsync(GetName());
                break;
            case "copy_format":
                {
                    DiscordAppSlashCommand? cmd = null;
                    if (string.IsNullOrEmpty(Data.ServerId))
                        App.SlashCommands.TryGetValue(Data.CommandFormat, out cmd);
                    else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                        sc.SlashCommands.TryGetValue(Data.CommandFormat, out cmd);

                    if (cmd == null && Data.CommandFormat.Contains(" "))
                    {
                        if (string.IsNullOrEmpty(Data.ServerId))
                            App.SlashCommands.TryGetValue(Data.CommandFormat.Split(' ').First(), out cmd);
                        else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                            sc.SlashCommands.TryGetValue(Data.CommandFormat.Split(' ').First(), out cmd);
                    }

                    if (cmd != null)
                        _ = JS.CopyTextAsync($"</{Data.CommandFormat}:{cmd.CommandId}>");
                }
                break;
            case "copy_id":
                {
                    DiscordAppSlashCommand? cmd = null;
                    if (string.IsNullOrEmpty(Data.ServerId))
                        App.SlashCommands.TryGetValue(Data.CommandFormat, out cmd);
                    else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                        sc.SlashCommands.TryGetValue(Data.CommandFormat, out cmd);

                    if (cmd == null && Data.CommandFormat.Contains(" "))
                    {
                        if (string.IsNullOrEmpty(Data.ServerId))
                            App.SlashCommands.TryGetValue(Data.CommandFormat.Split(' ').First(), out cmd);
                        else if (App.ServerCommands.TryGetValue(Data.ServerId, out var sc))
                            sc.SlashCommands.TryGetValue(Data.CommandFormat.Split(' ').First(), out cmd);
                    }

                    if (cmd != null)
                        _ = JS.CopyTextAsync(cmd.CommandId);
                }
                break;
        }
        
    }
}
