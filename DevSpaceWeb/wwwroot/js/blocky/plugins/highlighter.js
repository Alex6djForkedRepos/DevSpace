/*! For license information please see index.js.LICENSE.txt */

!function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(require("blockly/core")); else if ("function" == typeof define && define.amd) define(["blockly/core"], e); else { var s = "object" == typeof exports ? e(require("blockly/core")) : e(t.Blockly); for (var i in s) ("object" == typeof exports ? exports : t)[i] = s[i] } }(this, (t => (() => { "use strict"; var e = { 370: e => { e.exports = t } }, s = {}; function i(t) { var o = s[t]; if (void 0 !== o) return o.exports; var r = s[t] = { exports: {} }; return e[t](r, r.exports, i), r.exports } i.n = t => { var e = t && t.__esModule ? () => t.default : () => t; return i.d(e, { a: e }), e }, i.d = (t, e) => { for (var s in e) i.o(e, s) && !i.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: e[s] }) }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }; var o = {}; i.r(o), i.d(o, { ContentHighlight: () => h }); var r = i(370); const n = [r.Events.VIEWPORT_CHANGE, r.Events.BLOCK_CREATE, r.Events.BLOCK_MOVE, r.Events.BLOCK_DELETE, r.Events.COMMENT_MOVE, r.Events.COMMENT_CREATE, r.Events.COMMENT_DELETE]; class h { constructor(t) { this.workspace = t, this.width = 0, this.height = 0, this.top = 0, this.left = 0, this.lastScale = 1, this.padding = 10 } init(t) { this.padding = t || 10, this.svgGroup = r.utils.dom.createSvgElement(r.utils.Svg.G, { class: "contentAreaHighlight" }, null); const e = String(Math.random()).substring(2), s = r.utils.dom.createSvgElement(new r.utils.Svg("mask"), { id: "contentAreaHighlightMask" + e }, this.svgGroup); r.utils.dom.createSvgElement(r.utils.Svg.RECT, { x: 0, y: 0, width: "100%", height: "100%", fill: "white" }, s), this.rect = r.utils.dom.createSvgElement(r.utils.Svg.RECT, { x: 0, y: 0, rx: r.bubbles.Bubble.BORDER_WIDTH, ry: r.bubbles.Bubble.BORDER_WIDTH, fill: "black" }, s), this.background = r.utils.dom.createSvgElement(r.utils.Svg.RECT, { x: 0, y: 0, width: "100%", height: "100%", mask: `url(#contentAreaHighlightMask${e})` }, this.svgGroup), this.applyColor(); const i = this.workspace.getMetricsManager(); this.cachedContentMetrics = i.getContentMetrics(!0), this.resize(this.cachedContentMetrics); const o = i.getAbsoluteMetrics(); this.position(this.cachedContentMetrics, o), this.svgGroup.style.transition = "opacity 0.25s"; const n = this.workspace.getParentSvg(); n.firstChild ? n.insertBefore(this.svgGroup, n.firstChild) : n.appendChild(this.svgGroup), this.onChangeWrapper = this.onChange.bind(this), this.workspace.addChangeListener(this.onChangeWrapper) } dispose() { this.svgGroup && r.utils.dom.removeNode(this.svgGroup), this.onChangeWrapper && this.workspace.removeChangeListener(this.onChangeWrapper) } onChange(t) { if (t.type === r.Events.THEME_CHANGE) this.applyColor(); else if (-1 !== n.indexOf(t.type)) { const e = this.workspace.getMetricsManager(); t.type !== r.Events.VIEWPORT_CHANGE && (this.cachedContentMetrics = e.getContentMetrics(!0), this.resize(this.cachedContentMetrics)); const s = e.getAbsoluteMetrics(); this.cachedContentMetrics && this.position(this.cachedContentMetrics, s) } else if (t.type === r.Events.BLOCK_DRAG) this.handleBlockDrag(t); else if (t.type === r.Events.BLOCK_CHANGE) { const t = this.workspace.getMetricsManager(); this.cachedContentMetrics = t.getContentMetrics(!0), this.resize(this.cachedContentMetrics) } } handleBlockDrag(t) { var e; const s = t.isStart ? "0" : "1"; null === (e = this.svgGroup) || void 0 === e || e.setAttribute("opacity", s) } applyColor() { var t; const e = this.workspace.getTheme().getComponentStyle("workspaceBackgroundColour") || "#ffffff", s = r.utils.colour.blend("#000", e, .1), i = r.utils.colour.blend("#fff", e, .1), o = "#ffffff" === e || "#fff" === e ? s : i; o && (null === (t = this.background) || void 0 === t || t.setAttribute("fill", o)) } resize(t) { var e, s; const i = t.width ? t.width + 2 * this.padding : 0, o = t.height ? t.height + 2 * this.padding : 0; i !== this.width && (this.width = i, null === (e = this.rect) || void 0 === e || e.setAttribute("width", `${i}`)), o !== this.height && (this.height = o, null === (s = this.rect) || void 0 === s || s.setAttribute("height", `${o}`)) } position(t, e) { var s; const i = -this.workspace.scrollY, o = -this.workspace.scrollX, r = this.workspace.scale, n = e.top + t.top * r - i - this.padding * r, h = e.left + t.left * r - o - this.padding * r; n === this.top && h === this.left && this.lastScale === r || (this.top = n, this.left = h, this.lastScale = r, null === (s = this.rect) || void 0 === s || s.setAttribute("transform", `translate(${h}, ${n}) scale(${r})`)) } } return o })()));